import strawberry
from typing import List, Optional 
# EN: Added HTTPException and status for auth checks
# RU: –î–æ–±–∞–≤–ª–µ–Ω HTTPException –∏ status –¥–ª—è –ø—Ä–æ–≤–µ—Ä–æ–∫ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
from fastapi import Depends, HTTPException, status 
from datetime import datetime 
from strawberry.fastapi import GraphQLRouter
from sqlmodel import select
from sqlalchemy.ext.asyncio import AsyncSession
# EN: Added BaseModel and field_validator from Pydantic for DTOs and validation
# RU: –î–æ–±–∞–≤–ª–µ–Ω—ã BaseModel –∏ field_validator –∏–∑ Pydantic –¥–ª—è DTO –∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
from pydantic import BaseModel, field_validator 
from ..db import async_session
from ..models import Line, Machine, AuditLog, User, Repair
# EN: Import the authentication and RBAC helpers
# RU: –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –∏ RBAC
from ..auth import get_current_user, has_role 

async def get_session() -> AsyncSession:
    async with async_session() as s:
        yield s

# ----------------------------------------------------
# EN: Context getter uses real authentication (SECURITY FIX)
# RU: Context getter –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ä–µ–∞–ª—å–Ω—É—é –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é (–ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–ò)
# ----------------------------------------------------
def get_context(
    session: AsyncSession = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    # EN: The real authenticated user is now passed to the context
    # RU: –†–µ–∞–ª—å–Ω—ã–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ç–µ–ø–µ—Ä—å –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç
    return {"session": session, "user": current_user} 

# ----------------------------------------------------
# EN: Strawberry Resolver Authorization Decorator (RBAC)
# RU: –î–µ–∫–æ—Ä–∞—Ç–æ—Ä –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –¥–ª—è —Ä–µ–∑–æ–ª–≤–µ—Ä–æ–≤ Strawberry (RBAC)
# ----------------------------------------------------
def requires_role_graphql(required_role_name: str):
    def decorator(func):
        async def wrapper(*args, info: strawberry.type.Info, **kwargs):
            user: User = info.context.get("user")
            
            # EN: Check if the user is authenticated and has the required role
            # RU: –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏ –∏–º–µ–µ—Ç –ª–∏ —Ç—Ä–µ–±—É–µ–º—É—é —Ä–æ–ª—å
            if not user or not has_role(user, required_role_name):
                # EN: Raise 403 Forbidden
                # RU: –í—ã–∑—ã–≤–∞–µ–º 403 Forbidden
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN, 
                    detail=f"Permission denied. Requires role: {required_role_name}"
                )
            
            # EN: If check passes, execute the original resolver function
            # RU: –ï—Å–ª–∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–π–¥–µ–Ω–∞, –≤—ã–ø–æ–ª–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é —Ä–µ–∑–æ–ª–≤–µ—Ä–∞
            return await func(*args, info=info, **kwargs)
        return wrapper
    return decorator


# ----------------------------------------------------
# EN: Input Model for Repair Creation (DTO with Validation)
# RU: –ú–æ–¥–µ–ª—å –í—Ö–æ–¥–Ω—ã—Ö –î–∞–Ω–Ω—ã—Ö –¥–ª—è –°–æ–∑–¥–∞–Ω–∏—è –†–µ–º–æ–Ω—Ç–∞ (DTO —Å –í–∞–ª–∏–¥–∞—Ü–∏–µ–π)
# ----------------------------------------------------
class RepairCreateInput(BaseModel):
    machine_id: int
    title: str
    description: Optional[str] = None
    started_at: datetime
    finished_at: Optional[datetime] = None

    # EN: Business logic validation: finished time must be strictly after start time
    # RU: –í–∞–ª–∏–¥–∞—Ü–∏—è –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∏: –≤—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Å—Ç—Ä–æ–≥–æ –ø–æ—Å–ª–µ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞—á–∞–ª–∞
    @field_validator('finished_at')
    @classmethod
    def validate_dates(cls, v, info):
        if info.data.get('started_at') and v and v <= info.data['started_at']:
            # EN: Raise validation error if finish time is not logical
            # RU: –í—ã–∑—ã–≤–∞–µ–º –æ—à–∏–±–∫—É –≤–∞–ª–∏–¥–∞—Ü–∏–∏, –µ—Å–ª–∏ –≤—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è –Ω–µ–ª–æ–≥–∏—á–Ω–æ
            raise ValueError('Finished time must be strictly after started time.')
        return v

# --------------------
# EN: GraphQL Types
# --------------------

@strawberry.type
class LineType:
    id: int
    name: str
    is_deleted: bool 
    
@strawberry.type
class MachineType:
    id: int
    asset: str
    line_id: int
    is_deleted: bool 
    
@strawberry.type
class RepairType:
    id: int
    machine_id: int
    title: str
    description: Optional[str] = None
    started_at: datetime
    finished_at: Optional[datetime] = None
    created_by: int
    is_deleted: bool 

# --------------------
# EN: GraphQL Queries (Protected by context_getter)
# --------------------

@strawberry.type
class Query:
    @strawberry.field
    async def lines(self, info) -> List[LineType]:
        session: AsyncSession = info.context["session"]
        # EN: Only select active (non-deleted) lines
        # RU: –í—ã–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ (–Ω–µ —É–¥–∞–ª–µ–Ω–Ω—ã–µ) –ª–∏–Ω–∏–∏
        res = await session.execute(select(Line).where(Line.is_deleted == False))
        return [LineType(id=l.id, name=l.name, is_deleted=l.is_deleted) for l in res.scalars().all()]

    @strawberry.field
    async def machines(self, info) -> List[MachineType]:
        session: AsyncSession = info.context["session"]
        # EN: Only select active (non-deleted) machines
        # RU: –í—ã–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ (–Ω–µ —É–¥–∞–ª–µ–Ω–Ω—ã–µ) —Å—Ç–∞–Ω–∫–∏
        res = await session.execute(select(Machine).where(Machine.is_deleted == False))
        return [MachineType(id=m.id, asset=m.asset, line_id=m.line_id, is_deleted=m.is_deleted) for m in res.scalars().all()]

# --------------------
# EN: GraphQL Mutations (Protected by RBAC)
# --------------------

@strawberry.type
class Mutation:
    @requires_role_graphql("Admin") # <-- RBAC: –¢–æ–ª—å–∫–æ Admin –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å –ª–∏–Ω–∏–∏
    @strawberry.mutation
    async def create_line(self, info, name: str) -> LineType:
        session: AsyncSession = info.context["session"]
        user: User = info.context["user"]
             
        # EN: Core Business Logic: Create new Line
        # RU: –û—Å–Ω–æ–≤–Ω–∞—è –ë–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞: –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –ª–∏–Ω–∏–∏
        new_line = Line(name=name)
        session.add(new_line)
        await session.commit()
        await session.refresh(new_line)

        # üí° EN: AUDIT LOGGING: Record the creation event
        # üí° RU: –õ–û–ì–ò–†–û–í–ê–ù–ò–ï –ê–£–î–ò–¢–ê: –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏–µ —Å–æ–∑–¥–∞–Ω–∏—è
        audit = AuditLog(
            entity="Line",
            entity_id=str(new_line.id),
            action="CREATE",
            performed_by=user.id,
            diff={"name": name}
        )
        session.add(audit)
        await session.commit()
        
        return LineType(id=new_line.id, name=new_line.name, is_deleted=new_line.is_deleted)

    @requires_role_graphql("Technician") # <-- RBAC: –¢–æ–ª—å–∫–æ Technician –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å —Ä–µ–º–æ–Ω—Ç—ã
    @strawberry.mutation
    async def create_repair(self, info, data: RepairCreateInput) -> RepairType:
        session: AsyncSession = info.context["session"]
        user: User = info.context["user"] 
        
        # EN: Core Business Logic: Create new Repair
        # RU: –û—Å–Ω–æ–≤–Ω–∞—è –ë–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞: –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –†–µ–º–æ–Ω—Ç–∞
        new_repair = Repair(
            **data.model_dump(), 
            created_by=user.id
        )
        
        session.add(new_repair)
        await session.commit()
        await session.refresh(new_repair)

        # üí° EN: AUDIT LOGGING
        # üí° RU: –õ–û–ì–ò–†–û–í–ê–ù–ò–ï –ê–£–î–ò–¢–ê
        audit = AuditLog(
            entity="Repair",
            entity_id=str(new_repair.id),
            action="CREATE",
            performed_by=user.id,
            diff=data.model_dump()
        )
        session.add(audit)
        await session.commit()
        
        return RepairType(**new_repair.model_dump())

# --------------------
# EN: Final Schema setup
# --------------------
schema = strawberry.Schema(query=Query, mutation=Mutation)

graphql_app = GraphQLRouter(schema, context_getter=get_context)