import strawberry
from typing import List, Optional 
# EN: Added HTTPException for auth checks
# RU: –î–æ–±–∞–≤–ª–µ–Ω HTTPException –¥–ª—è –ø—Ä–æ–≤–µ—Ä–æ–∫ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
from fastapi import Depends, HTTPException
from datetime import datetime 
from strawberry.fastapi import GraphQLRouter
from sqlmodel import select
from sqlalchemy.ext.asyncio import AsyncSession
# EN: Added BaseModel and field_validator from Pydantic for DTOs and validation
# RU: –î–æ–±–∞–≤–ª–µ–Ω—ã BaseModel –∏ field_validator –∏–∑ Pydantic –¥–ª—è DTO –∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
from pydantic import BaseModel, field_validator 
from ..db import async_session
from ..models import Line, Machine, AuditLog, User, Repair
# EN: Import the new dependency for getting the current authenticated user
# RU: –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –Ω–æ–≤—É—é –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
from ..auth import get_current_user 

async def get_session() -> AsyncSession:
    async with async_session() as s:
        yield s

# ----------------------------------------------------
# EN: Context getter updated to use real authentication (SECURITY FIX)
# RU: Context getter –æ–±–Ω–æ–≤–ª–µ–Ω –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ä–µ–∞–ª—å–Ω–æ–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ (–ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–ò)
# ----------------------------------------------------
# EN: current_user is provided by the JWT dependency
# RU: current_user –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è JWT –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å—é
def get_context(
    session: AsyncSession = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    # EN: The real authenticated user is now passed to the context
    # RU: –†–µ–∞–ª—å–Ω—ã–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ç–µ–ø–µ—Ä—å –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç
    return {"session": session, "user": current_user} 

# ----------------------------------------------------
# EN: Input Model for Repair Creation (DTO with Validation)
# RU: –ú–æ–¥–µ–ª—å –í—Ö–æ–¥–Ω—ã—Ö –î–∞–Ω–Ω—ã—Ö –¥–ª—è –°–æ–∑–¥–∞–Ω–∏—è –†–µ–º–æ–Ω—Ç–∞ (DTO —Å –í–∞–ª–∏–¥–∞—Ü–∏–µ–π)
# ----------------------------------------------------
class RepairCreateInput(BaseModel):
    machine_id: int
    title: str
    description: Optional[str] = None
    started_at: datetime
    finished_at: Optional[datetime] = None

    # EN: Business logic validation: finished time must be after start time
    # RU: –í–∞–ª–∏–¥–∞—Ü–∏—è –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∏: –≤—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Å—Ç—Ä–æ–≥–æ –ø–æ—Å–ª–µ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞—á–∞–ª–∞
    @field_validator('finished_at')
    @classmethod
    def validate_dates(cls, v, info):
        if info.data.get('started_at') and v and v <= info.data['started_at']:
            # EN: Raise validation error if finish time is not logical
            # RU: –í—ã–∑—ã–≤–∞–µ–º –æ—à–∏–±–∫—É –≤–∞–ª–∏–¥–∞—Ü–∏–∏, –µ—Å–ª–∏ –≤—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è –Ω–µ–ª–æ–≥–∏—á–Ω–æ
            raise ValueError('Finished time must be strictly after started time.')
        return v

# --------------------
# EN: GraphQL Types
# --------------------

@strawberry.type
class LineType:
    id: int
    name: str
    is_deleted: bool 
    
@strawberry.type
class MachineType:
    id: int
    asset: str
    line_id: int
    is_deleted: bool 
    
@strawberry.type
class RepairType:
    id: int
    machine_id: int
    title: str
    description: Optional[str] = None
    started_at: datetime
    finished_at: Optional[datetime] = None
    created_by: int
    is_deleted: bool # EN: Added soft delete flag

# --------------------
# EN: GraphQL Queries (Requires Authentication)
# --------------------

@strawberry.type
class Query:
    @strawberry.field
    async def lines(self, info) -> List[LineType]:
        # EN: Authentication is now implicitly required by the context_getter
        # RU: –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è —Ç–µ–ø–µ—Ä—å –Ω–µ—è–≤–Ω–æ —Ç—Ä–µ–±—É–µ—Ç—Å—è —á–µ—Ä–µ–∑ context_getter
        session: AsyncSession = info.context["session"]
        
        # EN: Only select active (non-deleted) lines
        # RU: –í—ã–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ (–Ω–µ —É–¥–∞–ª–µ–Ω–Ω—ã–µ) –ª–∏–Ω–∏–∏
        res = await session.execute(select(Line).where(Line.is_deleted == False))
        return [LineType(id=l.id, name=l.name, is_deleted=l.is_deleted) for l in res.scalars().all()]

    @strawberry.field
    async def machines(self, info) -> List[MachineType]:
        session: AsyncSession = info.context["session"]
        # EN: Only select active (non-deleted) machines
        # RU: –í—ã–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ (–Ω–µ —É–¥–∞–ª–µ–Ω–Ω—ã–µ) —Å—Ç–∞–Ω–∫–∏
        res = await session.execute(select(Machine).where(Machine.is_deleted == False))
        return [MachineType(id=m.id, asset=m.asset, line_id=m.line_id, is_deleted=m.is_deleted) for m in res.scalars().all()]

# --------------------
# EN: GraphQL Mutations (Core MVP Functionality)
# --------------------

@strawberry.type
class Mutation:
    @strawberry.mutation
    async def create_line(self, info, name: str) -> LineType:
        session: AsyncSession = info.context["session"]
        user: User = info.context["user"] # EN: User is guaranteed to exist now (from context)
        
        # ‚ö†Ô∏è EN: RBAC CHECK (Future implementation needed, e.g., only Admins can create lines)
        # ‚ö†Ô∏è RU: –ü–†–û–í–ï–†–ö–ê RBAC (–¢—Ä–µ–±—É–µ—Ç—Å—è –±—É–¥—É—â–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è, –Ω–∞–ø—Ä–∏–º–µ—Ä, —Ç–æ–ª—å–∫–æ –ê–¥–º–∏–Ω—ã –º–æ–≥—É—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å –ª–∏–Ω–∏–∏)
             
        # EN: Core Business Logic: Create new Line
        # RU: –û—Å–Ω–æ–≤–Ω–∞—è –ë–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞: –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –ª–∏–Ω–∏–∏
        new_line = Line(name=name)
        session.add(new_line)
        await session.commit()
        await session.refresh(new_line)

        # üí° EN: AUDIT LOGGING: Record the creation event
        # üí° RU: –õ–û–ì–ò–†–û–í–ê–ù–ò–ï –ê–£–î–ò–¢–ê: –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏–µ —Å–æ–∑–¥–∞–Ω–∏—è
        audit = AuditLog(
            entity="Line",
            entity_id=str(new_line.id),
            action="CREATE",
            performed_by=user.id,
            diff={"name": name}
        )
        session.add(audit)
        await session.commit()
        
        return LineType(id=new_line.id, name=new_line.name, is_deleted=new_line.is_deleted)

    @strawberry.mutation
    async def create_repair(self, info, data: RepairCreateInput) -> RepairType:
        session: AsyncSession = info.context["session"]
        user: User = info.context["user"] # EN: User is guaranteed to exist now (from context)

        # ‚ö†Ô∏è EN: RBAC CHECK (Future implementation needed, e.g., only Technicians can create repairs)
        # ‚ö†Ô∏è RU: –ü–†–û–í–ï–†–ö–ê RBAC (–¢—Ä–µ–±—É–µ—Ç—Å—è –±—É–¥—É—â–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è, –Ω–∞–ø—Ä–∏–º–µ—Ä, —Ç–æ–ª—å–∫–æ –¢–µ—Ö–Ω–∏–∫–∏ –º–æ–≥—É—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å —Ä–µ–º–æ–Ω—Ç—ã)
        
        # EN: Core Business Logic: Create new Repair
        # RU: –û—Å–Ω–æ–≤–Ω–∞—è –ë–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞: –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –†–µ–º–æ–Ω—Ç–∞
        new_repair = Repair(
            **data.model_dump(), # EN: Use Pydantic's method to convert to dict
            created_by=user.id
        )
        
        session.add(new_repair)
        await session.commit()
        await session.refresh(new_repair)

        # üí° EN: AUDIT LOGGING
        # üí° RU: –õ–û–ì–ò–†–û–í–ê–ù–ò–ï –ê–£–î–ò–¢–ê
        audit = AuditLog(
            entity="Repair",
            entity_id=str(new_repair.id),
            action="CREATE",
            performed_by=user.id,
            diff=data.model_dump()
        )
        session.add(audit)
        await session.commit()
        
        return RepairType(**new_repair.model_dump())

# --------------------
# EN: Final Schema setup
# --------------------
schema = strawberry.Schema(query=Query, mutation=Mutation)

graphql_app = GraphQLRouter(schema, context_getter=get_context)