from datetime import datetime, timedelta, timezone
from fastapi import APIRouter, Depends, HTTPException, status, Header # EN: Added Header for token access
# EN: Added Redis for revocation list
# RU: –î–æ–±–∞–≤–ª–µ–Ω Redis –¥–ª—è —Å–ø–∏—Å–∫–∞ –æ—Ç–∑—ã–≤–∞
import redis
import json
from fastapi.security import OAuth2PasswordRequestForm, OAuth2PasswordBearer 
from jose import jwt, JWTError
from passlib.context import CryptContext
from sqlmodel import select
from sqlalchemy.ext.asyncio import AsyncSession
from .config import settings
from .db import async_session
from .models import User

router = APIRouter(prefix="/auth", tags=["auth"])
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
ALGO = "HS256"

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/login") 

# ----------------------------------------------------
# EN: Redis client setup for Token Revocation List
# RU: –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–ª–∏–µ–Ω—Ç–∞ Redis –¥–ª—è –°–ø–∏—Å–∫–∞ –û—Ç–∑—ã–≤–∞ –¢–æ–∫–µ–Ω–æ–≤
# ----------------------------------------------------
# EN: Use decode_responses=True to get strings instead of bytes
# RU: –ò—Å–ø–æ–ª—å–∑—É–µ–º decode_responses=True –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç—Ä–æ–∫ –≤–º–µ—Å—Ç–æ –±–∞–π—Ç–æ–≤
redis_client = redis.from_url(settings.redis_url, decode_responses=True)

async def get_session() -> AsyncSession:
    async with async_session() as s:
        yield s

def hash_password(p: str) -> str:
    return pwd_context.hash(p)

def verify_password(plain, hashed) -> bool:
    return pwd_context.verify(plain, hashed)

def create_token(sub: str, minutes: int):
    exp = datetime.now(timezone.utc) + timedelta(minutes=minutes) # EN: Use timezone.utc for consistency
    to_encode = {"sub": sub, "exp": exp.timestamp()} # EN: Use timestamp for JOSE
    return jwt.encode(to_encode, settings.jwt_secret, algorithm=ALGO)

# EN: Function to add a token to the blacklist with its remaining expiry time
# RU: –§—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞ –≤ —á–µ—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫ —Å –æ—Å—Ç–∞–≤—à–∏–º—Å—è —Å—Ä–æ–∫–æ–º –¥–µ–π—Å—Ç–≤–∏—è
def revoke_token(token: str):
    try:
        # EN: Decode without verification to get expiry time
        # RU: –î–µ–∫–æ–¥–∏—Ä—É–µ–º –±–µ–∑ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∏—Å—Ç–µ—á–µ–Ω–∏—è
        payload = jwt.decode(token, settings.jwt_secret, algorithms=[ALGO], options={"verify_signature": False})
        
        token_id = token # EN: Using the token itself as the ID for simplicity
        exp_timestamp = payload.get("exp")
        
        if exp_timestamp is None:
            return False # EN: Cannot revoke token without expiry
            
        # EN: Calculate time to live (TTL) in seconds
        # RU: –í—ã—á–∏—Å–ª—è–µ–º –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ (TTL) –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
        ttl = max(0, int(exp_timestamp - datetime.now(timezone.utc).timestamp()))
        
        if ttl > 0:
            # EN: Add token ID to Redis blacklist set with the calculated expiry
            # RU: –î–æ–±–∞–≤–ª—è–µ–º ID —Ç–æ–∫–µ–Ω–∞ –≤ —á–µ—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫ Redis —Å –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã–º —Å—Ä–æ–∫–æ–º –∏—Å—Ç–µ—á–µ–Ω–∏—è
            redis_client.set(token_id, "revoked", ex=ttl) 
            return True
        return False
    except (JWTError, Exception) as e:
        print(f"Token revocation error: {e}")
        return False

# EN: Function to check if a token is in the blacklist
# RU: –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Ç–æ–∫–µ–Ω –≤ —á–µ—Ä–Ω–æ–º —Å–ø–∏—Å–∫–µ
def is_token_revoked(token: str) -> bool:
    return redis_client.exists(token) == 1

# ----------------------------------------------------
# EN: JWT Dependency with Revocation Check
# RU: –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç—å JWT —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –æ—Ç–∑—ã–≤–∞
# ----------------------------------------------------
async def get_current_user(
    session: AsyncSession = Depends(get_session),
    token: str = Depends(oauth2_scheme)
) -> User:
    # EN: üí° CRITICAL: Check if the token is revoked FIRST
    # RU: üí° –ö–†–ò–¢–ò–ß–ï–°–ö–ò: –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ—Ç–æ–∑–≤–∞–Ω –ª–∏ —Ç–æ–∫–µ–Ω –ü–ï–†–í–´–ú –î–ï–õ–û–ú
    if is_token_revoked(token):
        raise HTTPException(status_code=401, detail="Token revoked")
        
    try:
        payload = jwt.decode(token, settings.jwt_secret, algorithms=[ALGO])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise HTTPException(status_code=401, detail="Invalid authentication credentials (No subject)")
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid authentication credentials")

    # EN: Fetch user from DB (code simplified for brevity)
    # RU: –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –ë–î (–∫–æ–¥ —É–ø—Ä–æ—â–µ–Ω –¥–ª—è –∫—Ä–∞—Ç–∫–æ—Å—Ç–∏)
    user_q = await session.execute(select(User).where(User.id == int(user_id)))
    user = user_q.scalar_one_or_none()
    
    if user is None or not user.is_active:
        raise HTTPException(status_code=401, detail="User not found or inactive")
        
    return user 

# ... (has_role, RequiresRole remain the same) ...

@router.post("/login")
async def login(form: OAuth2PasswordRequestForm = Depends(), session: AsyncSession = Depends(get_session)):
    # ... (–ª–æ–≥–∏–∫–∞ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
    q = await session.execute(select(User).where(User.email == form.username))
    user = q.scalar_one_or_none()
    if not user or not verify_password(form.password, user.hashed_password):
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials")
        
    access = create_token(str(user.id), settings.jwt_expire_min)
    refresh = create_token(str(user.id), settings.jwt_expire_min * 24)
    return {"access_token": access, "refresh_token": refresh, "token_type": "bearer"}

@router.post("/refresh")
async def refresh(token: str = Header(..., alias="Authorization")): # EN: Get token from Authorization header
    # EN: Strip 'Bearer ' prefix if present
    # RU: –£–¥–∞–ª—è–µ–º –ø—Ä–µ—Ñ–∏–∫—Å 'Bearer ', –µ—Å–ª–∏ –æ–Ω –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç
    token = token.replace("Bearer ", "") 
    
    # üí° EN: CRITICAL: Check if the token is revoked
    # üí° RU: –ö–†–ò–¢–ò–ß–ï–°–ö–ò: –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ—Ç–æ–∑–≤–∞–Ω –ª–∏ —Ç–æ–∫–µ–Ω
    if is_token_revoked(token):
        raise HTTPException(status_code=401, detail="Token revoked")
        
    try:
        # EN: Decode to check expiry and subject
        # RU: –î–µ–∫–æ–¥–∏—Ä—É–µ–º –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è –∏ —Å—É–±—ä–µ–∫—Ç–∞
        payload = jwt.decode(token, settings.jwt_secret, algorithms=[ALGO])
        sub = payload.get("sub")
        if not sub:
            raise ValueError
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")
        
    # EN: Revoke old token immediately after generating a new one (optional, but good practice)
    # RU: –û—Ç–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ä—ã–π —Ç–æ–∫–µ–Ω —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–æ–≤–æ–≥–æ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –Ω–æ —Ö–æ—Ä–æ—à–∞—è –ø—Ä–∞–∫—Ç–∏–∫–∞)
    revoke_token(token) 
    
    return {"access_token": create_token(sub, settings.jwt_expire_min)}

# ----------------------------------------------------
# EN: New endpoint for user logout
# RU: –ù–æ–≤—ã–π —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –≤—ã—Ö–æ–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
# ----------------------------------------------------
@router.post("/logout")
async def logout(
    access_token: str = Header(..., alias="Authorization"),
    refresh_token: str = Header(..., alias="X-Refresh-Token") # EN: Assuming refresh token is passed in a custom header
):
    # EN: Extract raw token string
    # RU: –ò–∑–≤–ª–µ–∫–∞–µ–º —á–∏—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É —Ç–æ–∫–µ–Ω–∞
    access_token = access_token.replace("Bearer ", "")
    
    # EN: Revoke both tokens
    # RU: –û—Ç–∑—ã–≤–∞–µ–º –æ–±–∞ —Ç–æ–∫–µ–Ω–∞
    if not revoke_token(access_token) or not revoke_token(refresh_token):
        raise HTTPException(status_code=400, detail="One or both tokens could not be revoked.")
        
    return {"status": "success", "message": "Logged out successfully"}